// Autogenerated from Pigeon (v3.2.9), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

enum MessageType {
  BasicId,
  Location,
  Auth,
  SelfId,
  System,
  OperatorId,
  MessagePack,
}

enum ScanPriority {
  High,
  Low,
}

enum MessageSource {
  BluetoothLegacy,
  BluetoothLongRange,
  WifiNaN,
  WifiBeacon,
  Unknown,
}

enum IdType {
  None,
  Serial_Number,
  CAA_Registration_ID,
  UTM_Assigned_ID,
  Specific_Session_ID,
}

enum UaType {
  None,
  Aeroplane,
  Helicopter_or_Multirotor,
  Gyroplane,
  Hybrid_Lift,
  Ornithopter,
  Glider,
  Kite,
  Free_balloon,
  Captive_balloon,
  Airship,
  Free_fall_parachute,
  Rocket,
  Tethered_powered_aircraft,
  Ground_obstacle,
  Other,
}

enum AircraftStatus {
  Undeclared,
  Ground,
  Airborne,
  Emergency,
  Remote_ID_System_Failure,
}

enum HeightType {
  Takeoff,
  Ground,
}

enum HorizontalAccuracy {
  Unknown,
  kilometers_18_52,
  kilometers_7_408,
  kilometers_3_704,
  kilometers_1_852,
  meters_926,
  meters_555_6,
  meters_185_2,
  meters_92_6,
  meters_30,
  meters_10,
  meters_3,
  meters_1,
}

enum VerticalAccuracy {
  Unknown,
  meters_150,
  meters_45,
  meters_25,
  meters_10,
  meters_3,
  meters_1,
}

enum SpeedAccuracy {
  Unknown,
  meter_per_second_10,
  meter_per_second_3,
  meter_per_second_1,
  meter_per_second_0_3,
}

enum BluetoothState {
  Unknown,
  Resetting,
  Unsupported,
  Unauthorized,
  PoweredOff,
  PoweredOn,
}

enum WifiState {
  Disabling,
  Disabled,
  Enabling,
  Enabled,
}

enum AuthType {
  None,
  UAS_ID_Signature,
  Operator_ID_Signature,
  Message_Set_Signature,
  Network_Remote_ID,
  Specific_Authentication,
  Private_Use_0xA,
  Private_Use_0xB,
  Private_Use_0xC,
  Private_Use_0xD,
  Private_Use_0xE,
  Private_Use_0xF,
}

enum AircraftCategory {
  Undeclared,
  EU_Open,
  EU_Specific,
  EU_Certified,
}

enum AircraftClass {
  Undeclared,
  EU_Class_0,
  EU_Class_1,
  EU_Class_2,
  EU_Class_3,
  EU_Class_4,
  EU_Class_5,
  EU_Class_6,
}

enum OperatorLocationType {
  TakeOff,
  LiveGNSS,
  FixedLocation,
  Invalid,
}

enum ClassificationType {
  Undeclared,
  EU,
}

class BasicIdMessage {
  BasicIdMessage({
    required this.receivedTimestamp,
    required this.macAddress,
    this.source,
    this.rssi,
    required this.uasId,
    this.idType,
    this.uaType,
  });

  int receivedTimestamp;
  String macAddress;
  MessageSource? source;
  int? rssi;
  String uasId;
  IdType? idType;
  UaType? uaType;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['receivedTimestamp'] = receivedTimestamp;
    pigeonMap['macAddress'] = macAddress;
    pigeonMap['source'] = source?.index;
    pigeonMap['rssi'] = rssi;
    pigeonMap['uasId'] = uasId;
    pigeonMap['idType'] = idType?.index;
    pigeonMap['uaType'] = uaType?.index;
    return pigeonMap;
  }

  static BasicIdMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return BasicIdMessage(
      receivedTimestamp: pigeonMap['receivedTimestamp']! as int,
      macAddress: pigeonMap['macAddress']! as String,
      source: pigeonMap['source'] != null
          ? MessageSource.values[pigeonMap['source']! as int]
          : null,
      rssi: pigeonMap['rssi'] as int?,
      uasId: pigeonMap['uasId']! as String,
      idType: pigeonMap['idType'] != null
          ? IdType.values[pigeonMap['idType']! as int]
          : null,
      uaType: pigeonMap['uaType'] != null
          ? UaType.values[pigeonMap['uaType']! as int]
          : null,
    );
  }
}

class LocationMessage {
  LocationMessage({
    required this.receivedTimestamp,
    required this.macAddress,
    this.source,
    this.rssi,
    this.status,
    this.heightType,
    this.direction,
    this.speedHorizontal,
    this.speedVertical,
    this.latitude,
    this.longitude,
    this.altitudePressure,
    this.altitudeGeodetic,
    this.height,
    this.horizontalAccuracy,
    this.verticalAccuracy,
    this.baroAccuracy,
    this.speedAccuracy,
    this.time,
    this.timeAccuracy,
  });

  int receivedTimestamp;
  String macAddress;
  MessageSource? source;
  int? rssi;
  AircraftStatus? status;
  HeightType? heightType;
  double? direction;
  double? speedHorizontal;
  double? speedVertical;
  double? latitude;
  double? longitude;
  double? altitudePressure;
  double? altitudeGeodetic;
  double? height;
  HorizontalAccuracy? horizontalAccuracy;
  VerticalAccuracy? verticalAccuracy;
  VerticalAccuracy? baroAccuracy;
  SpeedAccuracy? speedAccuracy;
  int? time;
  double? timeAccuracy;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['receivedTimestamp'] = receivedTimestamp;
    pigeonMap['macAddress'] = macAddress;
    pigeonMap['source'] = source?.index;
    pigeonMap['rssi'] = rssi;
    pigeonMap['status'] = status?.index;
    pigeonMap['heightType'] = heightType?.index;
    pigeonMap['direction'] = direction;
    pigeonMap['speedHorizontal'] = speedHorizontal;
    pigeonMap['speedVertical'] = speedVertical;
    pigeonMap['latitude'] = latitude;
    pigeonMap['longitude'] = longitude;
    pigeonMap['altitudePressure'] = altitudePressure;
    pigeonMap['altitudeGeodetic'] = altitudeGeodetic;
    pigeonMap['height'] = height;
    pigeonMap['horizontalAccuracy'] = horizontalAccuracy?.index;
    pigeonMap['verticalAccuracy'] = verticalAccuracy?.index;
    pigeonMap['baroAccuracy'] = baroAccuracy?.index;
    pigeonMap['speedAccuracy'] = speedAccuracy?.index;
    pigeonMap['time'] = time;
    pigeonMap['timeAccuracy'] = timeAccuracy;
    return pigeonMap;
  }

  static LocationMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return LocationMessage(
      receivedTimestamp: pigeonMap['receivedTimestamp']! as int,
      macAddress: pigeonMap['macAddress']! as String,
      source: pigeonMap['source'] != null
          ? MessageSource.values[pigeonMap['source']! as int]
          : null,
      rssi: pigeonMap['rssi'] as int?,
      status: pigeonMap['status'] != null
          ? AircraftStatus.values[pigeonMap['status']! as int]
          : null,
      heightType: pigeonMap['heightType'] != null
          ? HeightType.values[pigeonMap['heightType']! as int]
          : null,
      direction: pigeonMap['direction'] as double?,
      speedHorizontal: pigeonMap['speedHorizontal'] as double?,
      speedVertical: pigeonMap['speedVertical'] as double?,
      latitude: pigeonMap['latitude'] as double?,
      longitude: pigeonMap['longitude'] as double?,
      altitudePressure: pigeonMap['altitudePressure'] as double?,
      altitudeGeodetic: pigeonMap['altitudeGeodetic'] as double?,
      height: pigeonMap['height'] as double?,
      horizontalAccuracy: pigeonMap['horizontalAccuracy'] != null
          ? HorizontalAccuracy.values[pigeonMap['horizontalAccuracy']! as int]
          : null,
      verticalAccuracy: pigeonMap['verticalAccuracy'] != null
          ? VerticalAccuracy.values[pigeonMap['verticalAccuracy']! as int]
          : null,
      baroAccuracy: pigeonMap['baroAccuracy'] != null
          ? VerticalAccuracy.values[pigeonMap['baroAccuracy']! as int]
          : null,
      speedAccuracy: pigeonMap['speedAccuracy'] != null
          ? SpeedAccuracy.values[pigeonMap['speedAccuracy']! as int]
          : null,
      time: pigeonMap['time'] as int?,
      timeAccuracy: pigeonMap['timeAccuracy'] as double?,
    );
  }
}

class OperatorIdMessage {
  OperatorIdMessage({
    required this.receivedTimestamp,
    required this.macAddress,
    this.source,
    this.rssi,
    required this.operatorId,
  });

  int receivedTimestamp;
  String macAddress;
  MessageSource? source;
  int? rssi;
  String operatorId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['receivedTimestamp'] = receivedTimestamp;
    pigeonMap['macAddress'] = macAddress;
    pigeonMap['source'] = source?.index;
    pigeonMap['rssi'] = rssi;
    pigeonMap['operatorId'] = operatorId;
    return pigeonMap;
  }

  static OperatorIdMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return OperatorIdMessage(
      receivedTimestamp: pigeonMap['receivedTimestamp']! as int,
      macAddress: pigeonMap['macAddress']! as String,
      source: pigeonMap['source'] != null
          ? MessageSource.values[pigeonMap['source']! as int]
          : null,
      rssi: pigeonMap['rssi'] as int?,
      operatorId: pigeonMap['operatorId']! as String,
    );
  }
}

class AuthenticationMessage {
  AuthenticationMessage({
    required this.receivedTimestamp,
    required this.macAddress,
    this.source,
    this.rssi,
    this.authType,
    required this.authDataPage,
    required this.authLastPageIndex,
    required this.authLength,
    required this.authTimestamp,
    required this.authData,
  });

  int receivedTimestamp;
  String macAddress;
  MessageSource? source;
  int? rssi;
  AuthType? authType;
  int authDataPage;
  int authLastPageIndex;
  int authLength;
  int authTimestamp;
  String authData;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['receivedTimestamp'] = receivedTimestamp;
    pigeonMap['macAddress'] = macAddress;
    pigeonMap['source'] = source?.index;
    pigeonMap['rssi'] = rssi;
    pigeonMap['authType'] = authType?.index;
    pigeonMap['authDataPage'] = authDataPage;
    pigeonMap['authLastPageIndex'] = authLastPageIndex;
    pigeonMap['authLength'] = authLength;
    pigeonMap['authTimestamp'] = authTimestamp;
    pigeonMap['authData'] = authData;
    return pigeonMap;
  }

  static AuthenticationMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AuthenticationMessage(
      receivedTimestamp: pigeonMap['receivedTimestamp']! as int,
      macAddress: pigeonMap['macAddress']! as String,
      source: pigeonMap['source'] != null
          ? MessageSource.values[pigeonMap['source']! as int]
          : null,
      rssi: pigeonMap['rssi'] as int?,
      authType: pigeonMap['authType'] != null
          ? AuthType.values[pigeonMap['authType']! as int]
          : null,
      authDataPage: pigeonMap['authDataPage']! as int,
      authLastPageIndex: pigeonMap['authLastPageIndex']! as int,
      authLength: pigeonMap['authLength']! as int,
      authTimestamp: pigeonMap['authTimestamp']! as int,
      authData: pigeonMap['authData']! as String,
    );
  }
}

class SelfIdMessage {
  SelfIdMessage({
    required this.receivedTimestamp,
    required this.macAddress,
    this.source,
    this.rssi,
    required this.descriptionType,
    required this.operationDescription,
  });

  int receivedTimestamp;
  String macAddress;
  MessageSource? source;
  int? rssi;
  int descriptionType;
  String operationDescription;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['receivedTimestamp'] = receivedTimestamp;
    pigeonMap['macAddress'] = macAddress;
    pigeonMap['source'] = source?.index;
    pigeonMap['rssi'] = rssi;
    pigeonMap['descriptionType'] = descriptionType;
    pigeonMap['operationDescription'] = operationDescription;
    return pigeonMap;
  }

  static SelfIdMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SelfIdMessage(
      receivedTimestamp: pigeonMap['receivedTimestamp']! as int,
      macAddress: pigeonMap['macAddress']! as String,
      source: pigeonMap['source'] != null
          ? MessageSource.values[pigeonMap['source']! as int]
          : null,
      rssi: pigeonMap['rssi'] as int?,
      descriptionType: pigeonMap['descriptionType']! as int,
      operationDescription: pigeonMap['operationDescription']! as String,
    );
  }
}

class SystemDataMessage {
  SystemDataMessage({
    required this.receivedTimestamp,
    required this.macAddress,
    this.source,
    this.rssi,
    this.operatorLocationType,
    this.classificationType,
    required this.operatorLatitude,
    required this.operatorLongitude,
    required this.areaCount,
    required this.areaRadius,
    required this.areaCeiling,
    required this.areaFloor,
    this.category,
    this.classValue,
    required this.operatorAltitudeGeo,
  });

  int receivedTimestamp;
  String macAddress;
  MessageSource? source;
  int? rssi;
  OperatorLocationType? operatorLocationType;
  ClassificationType? classificationType;
  double operatorLatitude;
  double operatorLongitude;
  int areaCount;
  int areaRadius;
  double areaCeiling;
  double areaFloor;
  AircraftCategory? category;
  AircraftClass? classValue;
  double operatorAltitudeGeo;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['receivedTimestamp'] = receivedTimestamp;
    pigeonMap['macAddress'] = macAddress;
    pigeonMap['source'] = source?.index;
    pigeonMap['rssi'] = rssi;
    pigeonMap['operatorLocationType'] = operatorLocationType?.index;
    pigeonMap['classificationType'] = classificationType?.index;
    pigeonMap['operatorLatitude'] = operatorLatitude;
    pigeonMap['operatorLongitude'] = operatorLongitude;
    pigeonMap['areaCount'] = areaCount;
    pigeonMap['areaRadius'] = areaRadius;
    pigeonMap['areaCeiling'] = areaCeiling;
    pigeonMap['areaFloor'] = areaFloor;
    pigeonMap['category'] = category?.index;
    pigeonMap['classValue'] = classValue?.index;
    pigeonMap['operatorAltitudeGeo'] = operatorAltitudeGeo;
    return pigeonMap;
  }

  static SystemDataMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SystemDataMessage(
      receivedTimestamp: pigeonMap['receivedTimestamp']! as int,
      macAddress: pigeonMap['macAddress']! as String,
      source: pigeonMap['source'] != null
          ? MessageSource.values[pigeonMap['source']! as int]
          : null,
      rssi: pigeonMap['rssi'] as int?,
      operatorLocationType: pigeonMap['operatorLocationType'] != null
          ? OperatorLocationType.values[pigeonMap['operatorLocationType']! as int]
          : null,
      classificationType: pigeonMap['classificationType'] != null
          ? ClassificationType.values[pigeonMap['classificationType']! as int]
          : null,
      operatorLatitude: pigeonMap['operatorLatitude']! as double,
      operatorLongitude: pigeonMap['operatorLongitude']! as double,
      areaCount: pigeonMap['areaCount']! as int,
      areaRadius: pigeonMap['areaRadius']! as int,
      areaCeiling: pigeonMap['areaCeiling']! as double,
      areaFloor: pigeonMap['areaFloor']! as double,
      category: pigeonMap['category'] != null
          ? AircraftCategory.values[pigeonMap['category']! as int]
          : null,
      classValue: pigeonMap['classValue'] != null
          ? AircraftClass.values[pigeonMap['classValue']! as int]
          : null,
      operatorAltitudeGeo: pigeonMap['operatorAltitudeGeo']! as double,
    );
  }
}

class ConnectionMessage {
  ConnectionMessage({
    required this.receivedTimestamp,
    required this.macAddress,
    this.source,
    this.rssi,
    required this.transportType,
    required this.lastSeen,
    required this.firstSeen,
    required this.msgDelta,
  });

  int receivedTimestamp;
  String macAddress;
  MessageSource? source;
  int? rssi;
  String transportType;
  int lastSeen;
  int firstSeen;
  int msgDelta;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['receivedTimestamp'] = receivedTimestamp;
    pigeonMap['macAddress'] = macAddress;
    pigeonMap['source'] = source?.index;
    pigeonMap['rssi'] = rssi;
    pigeonMap['transportType'] = transportType;
    pigeonMap['lastSeen'] = lastSeen;
    pigeonMap['firstSeen'] = firstSeen;
    pigeonMap['msgDelta'] = msgDelta;
    return pigeonMap;
  }

  static ConnectionMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConnectionMessage(
      receivedTimestamp: pigeonMap['receivedTimestamp']! as int,
      macAddress: pigeonMap['macAddress']! as String,
      source: pigeonMap['source'] != null
          ? MessageSource.values[pigeonMap['source']! as int]
          : null,
      rssi: pigeonMap['rssi'] as int?,
      transportType: pigeonMap['transportType']! as String,
      lastSeen: pigeonMap['lastSeen']! as int,
      firstSeen: pigeonMap['firstSeen']! as int,
      msgDelta: pigeonMap['msgDelta']! as int,
    );
  }
}

class _ApiCodec extends StandardMessageCodec {
  const _ApiCodec();
}

class Api {
  /// Constructor for [Api].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  Api({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ApiCodec();

  Future<void> startScanBluetooth() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.startScanBluetooth', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> startScanWifi() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.startScanWifi', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> stopScanBluetooth() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.stopScanBluetooth', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> stopScanWifi() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.stopScanWifi', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setBtScanPriority(ScanPriority arg_priority) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.setBtScanPriority', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_priority.index]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<bool> isScanningBluetooth() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.isScanningBluetooth', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> isScanningWifi() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.isScanningWifi', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<int> bluetoothState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.bluetoothState', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as int?)!;
    }
  }

  Future<int> wifiState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.wifiState', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as int?)!;
    }
  }

  Future<bool> btExtendedSupported() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.btExtendedSupported', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<int> btMaxAdvDataLen() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.btMaxAdvDataLen', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as int?)!;
    }
  }

  Future<bool> wifiNaNSupported() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Api.wifiNaNSupported', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }
}

class _MessageApiCodec extends StandardMessageCodec {
  const _MessageApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AuthenticationMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is BasicIdMessage) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is ConnectionMessage) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is LocationMessage) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is OperatorIdMessage) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is SelfIdMessage) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is SystemDataMessage) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AuthenticationMessage.decode(readValue(buffer)!);
      
      case 129:       
        return BasicIdMessage.decode(readValue(buffer)!);
      
      case 130:       
        return ConnectionMessage.decode(readValue(buffer)!);
      
      case 131:       
        return LocationMessage.decode(readValue(buffer)!);
      
      case 132:       
        return OperatorIdMessage.decode(readValue(buffer)!);
      
      case 133:       
        return SelfIdMessage.decode(readValue(buffer)!);
      
      case 134:       
        return SystemDataMessage.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class MessageApi {
  /// Constructor for [MessageApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MessageApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _MessageApiCodec();

  Future<int?> determineMessageType(Uint8List arg_payload, int arg_offset) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.determineMessageType', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as int?);
    }
  }

  Future<BasicIdMessage?> fromBufferBasic(Uint8List arg_payload, int arg_offset, String arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.fromBufferBasic', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset, arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as BasicIdMessage?);
    }
  }

  Future<LocationMessage?> fromBufferLocation(Uint8List arg_payload, int arg_offset, String arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.fromBufferLocation', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset, arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as LocationMessage?);
    }
  }

  Future<OperatorIdMessage?> fromBufferOperatorId(Uint8List arg_payload, int arg_offset, String arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.fromBufferOperatorId', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset, arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as OperatorIdMessage?);
    }
  }

  Future<SelfIdMessage?> fromBufferSelfId(Uint8List arg_payload, int arg_offset, String arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.fromBufferSelfId', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset, arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as SelfIdMessage?);
    }
  }

  Future<AuthenticationMessage?> fromBufferAuthentication(Uint8List arg_payload, int arg_offset, String arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.fromBufferAuthentication', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset, arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as AuthenticationMessage?);
    }
  }

  Future<SystemDataMessage?> fromBufferSystemData(Uint8List arg_payload, int arg_offset, String arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.fromBufferSystemData', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset, arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as SystemDataMessage?);
    }
  }

  Future<ConnectionMessage?> fromBufferConnection(Uint8List arg_payload, int arg_offset, String arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.fromBufferConnection', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_payload, arg_offset, arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ConnectionMessage?);
    }
  }
}
